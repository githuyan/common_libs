#### 并发处理之限流

**参考：**

- [微服务接口限流的设计与思考（附GitHub框架源码） (qq.com)](https://mp.weixin.qq.com/s/k9tm-4lBwm69nxnYp9octA) 



#### 目的

1. 巨大流量的平滑过度
2. 自定义限流名单
3. 自定义限流策略，多策略限流，动态限流，热更新
   1. 拒绝请求
   2. 延时处理
   3. 警告提醒
4. 流量数据统计

##### 没有限流可能会出现哪些问题

1. 大促场景的粗粒度限流，每秒都会有大量请求涌入，需要限制每一秒的流量数量
2. 作为服务接口的提供方，上游bug可能会导致某个时间的大量请求
3. 非预期流量的限流，恶意流量可能会占用过多的核心资源，导致正常请求服务超时或失败

##### 有限流可能会出现哪些问题

1. 高容错，限流服务的异常不影响系统的稳定性
2. 高TPS，限流服务本身的TPS要大于系统本身的TPS
3. 低延迟， 不能或者较小的影响接口本身的响应时间



#### 常用限流算法

##### 固定窗口算法

> 需要一个支持原子操作的计数器

简单的实现

```python
count_map = {}

def hit(amount, key: str):
    count_map.setdefault(key, 0)

    if count_map[key] >= amount:
        return False

    count_map[key] += 1

    return True
```

这是一个最简单的固定窗口限流，然而这个实现是存在问题的，

1. `count_map[key] += 1` 值得注意的是 `+=` 操作并不是原子性，实际上会解析成 `count_map[key] = count_map[key] + 1` 当在多线程的情况下存在竞态条件



##### 滑动窗口算法



##### 令牌桶算法



##### 漏桶算法



#### 限流策略

##### 阻塞式

> 额外流量入队



##### 否定式

> 拒绝额外流量



##### 提醒

> 额外流量警告提醒，日志记录，可用于测试限流服务的过渡流程



#### 功能实现

##### 需要注意的问题

1. 前后钩子应当是同步的
2. 单机与分布式
3. 同步与异步
4. 多个限流策略叠加的情况
5. 限流间隔选择（100/s, 100/m）



#### 扩展

##### 流量削峰

单机限流

分布式限流



##### 熔断