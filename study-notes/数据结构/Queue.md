## 3. 消费消息

不可见时间计时方法为：在消费者消费了消息后，不可见时间才开始计时，则不可见时间为消息被消费之后直到现在的时间。

当不可见时间 > 消息堆积周期时，消息被消费之后会永远不可见，直到超过堆积周期被队列删除，这样看着确实消息只被消费了一次，且不会被再消费了。
但是生产和消费的过程中有可能存在重复生产和消费失败等现象，只通过修改队列属性无法保证队列只消费一次，这里需要业务方来实现生产消费的去重和容错。

当大量的消费者同时消费消息时有可能需要排队等待队列服务，如果设置了等待时间为0，可能根本没有等到队列服务就已经超时，返回 no message 异常了，因此建议消息的等待时间不要设置为0。



## 4. 消息回溯

这里结合一个场景来描述消息回溯的使用：

假设有 A/B 两个业务，正常的生产消费场景，A 生产消息投递到队列中，B 从队列中消费消息，A/B 这时已经实现互相解耦，双方互不关心。A 只需要生产消息投递即可，B 从队列中拿到消息，然后将消息从队列中删除，接着在本地消费消息。

如果出现了异常，例如 B 业务虽然进行了消费，但是在一段时间内消费情况都出现了异常。这时，已经删除的消息已经被删除，无法重新消费，会对业务造成影响，且需要暂停 B 业务，等开发运维人员修复 Bug 之后才能重新上线 B 业务。而且运维人员也无法实时监控 B 业务的情况，等到发现异常场景，可能已经过去一段时间。

为了防止这种情况出现，A 业务需要关心 B 业务的处理情况，需要对生产消息进行备份，确保B 业务正常才能删除备份，保证现网正常。

这种情况下，您可以使用 **消息回溯** 的功能，开发人员对 B 业务进行修复，然后根据 B 业务消费正常的最近一个时间点，将消息回溯到该时间点。这时候，B 业务获取到的消息就会从指定的时间点开始，A 业务完全不用关心 B 业务的异常情况。这里 B 需要注意要对消费进行幂等处理。



# 消息生命周期

https://cloud.tencent.com/document/my-space/favorite)

普通消息被发送到普通消息队列时， 初始状态为 **Active**，当其被取走后在 VisibilityTimeout 的时间内状态为 **Inactive**，若超过 VisibilityTimeout 时间后消息还未被删除，消息会重新变成 **Active** 状态；如果在 VisibilityTimeout 时间内被删除，消息状态将变为 **Deleted**。消息的最长存活时间由创建队列时指定的 MessageRetentionPeriod 属性值决定， 超过此时间后消息状态变成 **Expired** 并将被回收。

消费者只能取到处于 **Active** 状态的消息。这保证了同一条消息不会同时被多次消费，但可被顺序性地多次消费。



### 消息队列 CMQ 支持 [Pull（队列）](https://cloud.tencent.com/document/product/406/6902) 和 [Push（主题）](https://cloud.tencent.com/document/product/406/6907) 两种方式：

- Push 模型：当 Producer 发出的消息到达后，服务端马上将这条消息投递给 Consumer。
- Pull 模型：当服务端收到这条消息后什么也不做，只是等着 Consumer 主动到自己这里来读，即 Consumer 这里有一个“拉取”的动作。

