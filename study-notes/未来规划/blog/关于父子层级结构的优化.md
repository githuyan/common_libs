### 关于父子层级结构的优化

#### 前言

父子层级结构的应用非常广泛，如省市级定义，部门层级定义等，但是父子层级结构也存在一些缺陷。

```python
└── 1
    ├── 2
    ├── 3
    └── 4
        └── 5
            └── 6
raw_nodes = [
    {"id": 1, "parent_id": 0},
    {"id": 2, "parent_id": 1},
    {"id": 3, "parent_id": 1},
    {"id": 4, "parent_id": 1},
    {"id": 5, "parent_id": 2},
    {"id": 6, "parent_id": 5},
]
```

父子层级结构常用`id, parent_id`作为锚定条件，构成一颗多叉树，父子级之间的关系可以被清晰的定义，子树的扭转，相邻级别的增删改查都极为方便。

但是父子级机构也存在缺点，那就是深度查询极为困难。上层想要查询所有子孙节点需要递归查询，

```sql
WITH RECURSIVE floor_tree(id, name, parent_id) AS (
    SELECT f.id, f.name, f.parent_id
    FROM floor f
    JOIN floor_tree ft ON f.parent_id = ft.id
)
SELECT id, name, parent_id FROM floor_tree;
```

遇到批量查询所有子孙节点是，情况更糟：

```python
    def dfs_depart(departs) -> Dict:
        """
        多叉树，深度优先遍历，获取每一个节点所对应子树的所有节点的映射
        raw_nodes = [
            {"id": 1, "parent_id": 0},
            {"id": 3, "parent_id": 1},
            {"id": 7, "parent_id": 3},
            {"id": 8, "parent_id": 7},
        ]
        data = dfs_depart(row_nodes)  # data = {1: [3,7,8], 3:  [7,8], 7: [8], 8:[]}

        Args:
            departs:

        Returns:

        """

        def inner_dfs_departs(nodes):
            if not nodes:
                return []

            for node in nodes:
                pid = node.get("depart_id")

                # 遍历原始数据，获取所有子节点
                sub_nodes = [node for node in departs if pid == node.get("parent_depart")]
                tmp = inner_dfs_departs(sub_nodes)
                # 剪枝，避免重复
                if pid not in data:
                    data.setdefault(pid, tmp)

            # 返回本子节点列表的所有值
            children = []
            for node in nodes:
                children.append(node.get("depart_id"))
                children.extend(data.get(node.get("depart_id"), []))
            return children

        data = {}
        inner_dfs_departs(departs)
        return data
```

像这样，不得不需要额外的处理才能获取所有的节点。



##### 结构优化



可能收到的影响：

1. 不定长字符串造成的性能浪费