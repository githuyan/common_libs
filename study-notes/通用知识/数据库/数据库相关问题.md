# 一些特性，细节，问题

mysql 数据库每页大小为16kb





### 数据库SQL优化

1. 对查询进行优化，要尽量避免全表扫描，考虑在 where 及 order by 涉及的列上建立索引
2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
3. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num=10 or Name = 'admin'
5. 下面的查询也将导致全表扫描select id from t where name like ‘%abc%’   若要提高效率，可以考虑全文检索。
6. 尽量避免在where子句中对字段模糊匹配，函数操作
7. 尽量避免在where子句中的=左边进行函数，算数运算，或其他表达式运算，如：select id from t where num/2 = 100应改为：select id from t where num = 100*29. 
8. 一个表的索引最好不要超过6个，因为索引提高了查询效率，但是减弱了插入和更新的效率
9. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
10. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定

索引数据结构为什么采用B+树     为了尽量减少I/O操作

### mysql表删一半数据，表空间会变小吗

不会，mysql执行delete操作后，存储在硬盘上的数据没有被删除，只不过在记录行上做了逻辑删除，即通过删除标识位实现。

因为移除它们之后，很多其他的记录需要在磁盘上重新排列，这样会消耗大量的性能，比如如果是一张大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的是要改变索引结构，必将带来磁盘IO，大家都知道磁盘IO是很浪费性能的。所有被删除的记录都会组成一个垃圾链表，这个链表中记录占用的空间叫做可重用空间，之后有新记录插入的时候可能把已删除记录占用的空间覆盖掉。

### 索引的优缺点   

**优点：**    

1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。     

2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。     

3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。    

4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。    

5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

 **缺点：**    

1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。     
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。     
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

 **哪些字段适合建索引**    

1. 在经常需要搜索的列上，可以加快搜索的速度；     
2. 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；    
3. 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；    
4. 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；     
5. 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；     
6. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 

**哪些字段不适合建索引**     

1.对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

### mongodb和Mysql的区别

**mysql**

1、在不同的引擎上有不同的存储方式。
 2、查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。
 3、开源数据库的份额在不断增加，mysql的份额页在持续增长。
 4、**缺点就是在海量数据处理的时候效率会显著变慢**。

**mongodb**

1、存储方式：虚拟内存+持久化。
 2、查询语句：是独特的MongoDB的查询方式。
 3、适合场景：事件的记录，内容管理或者博客平台等等。
 4、架构特点：可以通过副本集，以及分片来实现高可用。
 5、数据处理：**数据是存储在硬盘上的**，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。
 6、成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。

### 什么是ORM

是一种用于实现面向对象编程语言里不同类型数据之间转换的技术.，ORM解决的主要问题是对象关系的映射.我们在进行数据库操作的时候，通过ORM可以不用写一些专用的函数来进行的对数据的处理

ORM技术特点：
　　1.提高了开发效率.由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射,所以我们实际可能已经不需要一个专用的、庞大的数据访问层.
　　2.ORM提供了对数据库的映射,不用sql直接编码,能够像操作对象一样从数据库获取数据.

### 最左前缀原则

> MySQL 建立多列索引（联合索引）有最左匹配的原则，即最左优先：
> 如果有一个 2 列的索引 (a, b)，则已经对 (a)、(a, b) 上建立了索引；
> 如果有一个 3 列索引 (a, b, c)，则已经对 (a)、(a, b)、(a, b, c) 上建立了索引；

```sql
select * from t where a=1 and b=1 and c =1;     #这样可以利用到定义的索引（a,b,c）,用上a,b,c

select * from t where a=1 and b=1;     #这样可以利用到定义的索引（a,b,c）,用上a,b

select * from t where b=1 and a=1;     #这样可以利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器）

select * from t where a=1;     #这样也可以利用到定义的索引（a,b,c）,用上a

select * from t where b=1 and c=1;     #这样不可以利用到定义的索引（a,b,c）

select * from t where a=1 and c=1;     #这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到
```

**模糊匹配与范围匹配时**

> 对于索引中的字段，mysql会一直向右匹配直到遇到**范围查询(>、<、between、like) 后**就停止匹配

```sql
// (a, b, c) 联合索引，遇到b>1000时，最左匹配就会停止，结果就是用到了(a,b)索引，从没有用上，
select * from LOL where a = 2 and b > 1000  and c='JJJ疾风剑豪';

// 优化后，此时可以用上(a,b,c)索引，通过优化顺序节省了一个索引
select * from LOL where a = 2 and c='JJJ疾风剑豪' and b > 1000 ;
```







### redis的多个数据库有什么用？

> 没什么用，reids是单线程的，所以多个库并不能带来性能的提升
>
> 可以在一些不重要的地方稍微用一下第二个库，正常情况下不建议使用

![image-20220725212002079](../../../resource/image-20220725212002079.png)

### 大键和长SQL的危害

无论是redis中的大键（查询耗时严重）还是SQL中的长SQL（SQL太长会被截断）都会对性能造成影响

### innodb存储引擎的特性

1. **插入缓冲 （insert_buffer -> change_buffer)**

2. **预读**

   > 预读（read-ahead)操作是一种IO操作，用于异步将磁盘的页读取到buffer pool中
   >
   > 分区 extend ，一个extend有多个数据页 page

   1. Linear read-ahead（线性预读）

      > 当buffer pool 中有一定量的页被顺序访问，那么启动线性预读，预测到这些页临近的页也会很快被访问到，就从磁盘读取这些预测访问到的页加载到内存中，

      **配置：**

      ```python
      # 这个参数控制InnoDB在检测顺序页面访问模式时的灵敏度
      # 修改需要有set global 权限
      # 未添加这个参数时， InnoDB会在读取到当前区段最后一页时才会发起异步预读请求
      innodb_read_ahead_threshold = （0-64）
      
      比如，如果设置为48，在当前区块中当有48个页被顺序访问时，InnoDB就会启动异步的预读操作，如果设置为8，则仅仅有8个页被顺序访问就会启动异步预读操作。
      ```

   2. Random read-ahead（随即预读）

      > mysql5.5以废弃

3. **双写机制（double write)**

   > 在InnoDB将BP中的Dirty Page刷（flush）到磁盘上时，首先会将（memcpy函数）Page刷到InnoDB tablespace的一个区域中，我们称该区域为Double write Buffer（大小为2MB，每次写入1MB，128个页，每个页16k

   1. 在异常崩溃时，如果不出现“页数据损坏”，能够通过redo恢复数据；
   2. 在出现“页数据损坏”时，能够通过double write buffer恢复页数据

4. **自适应哈希索引（Adaptive Hash Index，AHI）**

   > hash的具有很高的读写性能
   >
   > InnoDB存储引擎会监控对表上辅助索引页的查询。如果观察到建立hash索引可以提升性能，就会在缓冲池建立hash索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
   >
   > **注意：** hash查询是等值查询，所以范围查询，模糊查询不能使用自适应哈希索引（AHI）
   >
   > 启用了AHI后，读写的速度会提升2倍，辅助索引的连接操作性能可以提高5倍。

   自适应哈希索引由innodb_adaptive_hash_index 变量启用,AHI是通过缓冲池的B+ Tree构造而来，使用索引键的前缀来构建哈希索引，前缀可以是任意长度。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立hash索引。加快索引读取的效果，相当于索引的索引，帮助InnoDB快速读取索引页。

   

### mysql的优化

**参考：**

- [(9条消息) 实践中如何优化MySQL（精）_Chackca的博客-CSDN博客_mysql优化](https://blog.csdn.net/qq_35642036/article/details/82820129)

1. 将多次插入换成批量Insert插入

2. 分页器越查越慢，可以通过通过ID执行查询起始位置优化

3. 分组时默认根据分组条件进行排序，没有必要的话可以直接禁止默认排序

   ```sql
   select group_id from users group by group_id order by NULL
   ```

4. 只返回必要的列，用具体的字段列表代替 select * 语句

5. 连表查询时，驱动表做小表，被驱动表做大表，如果优化器没有成功，可以强制指定

6. 根据情况可以强制指定索引

   ```sql
   select * from users force index	('inx_user_id') where name = 1
   ```

7. 优化group by 语句，尽量使用内存临时表，不要使用磁盘临时表，可以适当的修改temp_table_size

8. 在条件中，只有使用的字段与定义索引时指定的类型一致才能用到索引

9. 联合索引，最左匹配原则，覆盖索引，索引下推



### MVCC 是什么？

> 多版本并发控制，维持数据的多个版本(事务之类的)