### keep-alive模式

**参考：**

- https://zhuanlan.zhihu.com/p/34052073

​		由于http协议是无状态协议，非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接，当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。也即是说，一**个已经保持keep-alive的TCP连接，可以在本次请求结束后（请求-响应），再次服用这条连接**

使用keep-alive面模式的优点：

- TCP连接更少，这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。
- 网络拥塞也减少了，拿到响应的延时也减少了
- 更友好的错误处理，不会直接关闭，支持retry

**Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？**

1. 已知数据长度的静态数据通过消息首部字段Conent-Length字段

   Conent-Length表示实体内容长度，当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。

2. 未知数据长度流式数据使用消息首部字段Transfer-Encoding

   使用Transfer-Encoding：chunk模式：服务器就需要使用Transfer-Encoding: chunked这样的方式来代替Content-Length。即如果要一边产生数据，一边发给客户端。分区编码，**最后一个分块长度值必须为 0**，对应的分块数据没有内容，表示实体结束。



### http/2的多路复用

**参考：**

- [简单讲解一下 http/2 的多路复用](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14) 

​		在HTTP1.x中，并发多个请求需要多个TCP连接，即使使用了keep-alive技术，解决了多次连接的问题，但是其根本上http1.x串行文件传输的效率问题依然存在， **http1.x中其传输形式是一问一答的形式**，即便在在keep-alive中，也必须等下上一个请求接受才能发起下一个请求，所以会收到前面请求的阻塞[^队首阻塞]。

​		HTTP/2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效，在 HTTP/2 中，有两个非常重要的概念，分别是**帧**（frame）和**流**（stream）。**帧代表着最小的数据单位**，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流

​		http/2的传输是基于二进制帧的。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。**二进制帧的头部信息会标识自己属于哪一个流**，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。这样就解决了队首阻塞的问题，同时也提高了网络速度的利用率。
